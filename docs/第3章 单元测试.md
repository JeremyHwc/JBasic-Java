[toc]

## 一、原则

> 1. 单元测试必须遵守自动化、独立性和可重复性原则；
>
> 2. 单元测试的粒度一般是方法级别，最多也是类级别；
>
> 3. 核心业务、核心应用、核心模块的增量代码确保单元测试通过。

## 二、疑问

> 1. 什么是单元测试？
> 2. 为什么要编写单元测试？
> 3. 什么是好的单元测试？
> 4. 单元测试的常用框架有哪些？

## 三、单元测试相关概念

### 3.1、单元测试和集成测试

#### 3.1.1、单元测试

> 一个单元测试是一段代码，这段代码调用一个工作单元，并检验该工作单元的具体最终结果。
>
> 如果关于这个最终结果的假设是错误的，单元测试就失败了。
>
> 一个单元测试的范围可以小到一个方法，大到一个类

#### 3.1.2、集成测试

> 任何测试，如果它运行速度不快，结果不稳定，或者要用到被测试单元的一个或多个真实依赖，我就认为它是集成测试。
>
> 集成测试是对一个工作单元进行测试，这个测试对被测试的工作单元没有完全控制，并使用单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或随机数产生器等。

#### 3.1.3、单元测试与集成测试的区别

集成测试会使用真实的依赖，而单元测试则把被测试的单元和其依赖隔离，以保证单元测试的高度稳定，还可以轻易控制和模拟被测试单元的行为方面。**单元测试和集成测试最主要的区别之一就是测试中是否依赖 “真实环境”。**

### 3.2、单元测试的重要性

> 1. 单元测试可以让很多 BUG 在编码阶段就能够及时发现并解决，而不需要交给测试人员兜底，如果测试人员兜底失败，可能造成线上故障。
> 2. 有了单元测试作保障，我们还可以放心对函数进行重构，如果重构代码导致单元测试运行失败，则说明重构的代码有问题。
>
> 长远来看，单元测试对编码的益处（如提高代码质量和避免Bug）远比编写单元测试的投入所花费的代价要大得多。

### 3.3、单元测试的方法

主要包括两种方法，包括**传统的单测方法**和**测试驱动开发**。

#### 3.3.1、传统的单测方法

![](imgs\3\traditional_unit.png)

#### 3.3.2、测试驱动开发

![](imgs\3\tdd.png)

TDD体现的是“以终为始”的思想，即先制定目标，然后去验证是否实现了目标，而不是先做再去“思考目标”。

**实现TDD的关键步骤：**

- 编写一个失败的测试来证明产品中代码和功能的缺陷；
- 编写符合测试语气的产品代码，使测试通过；
- 重构代码

### 3.4、什么是好的单元测试？

> 1. 满足功能：被检验的函数或类的逻辑行为满足预期功能；
> 2. 满足AIR原则：单元测试可以自动执行；单元测试的用例之间要保持彼此独立；单元测试可以重复执行；
> 3. 编写容易，运行快速的特点。

### 4、Java单元测试工具

#### 4.1、常用Java单元测试框架

常用的Java单元测试有JUnit和TestNG，其中TestNG受JUnit和NUnit的启发，功能相似，但是比JUnit强大。TestNG不只为单元测试而设计，其框架的目标支持单元测试、公共能测试、端对端测试，集成测试等。

[TestNG官方文档](https://testng.org/doc/documentation-main.html )

#### 4.2、Java mock框架

##### 4.2.1、Mockito

 PowerMock 拓展，允许静态函数测试，社区强大，对结果的验证和异常处理非常简洁、灵活。缺点是框架本身不支持 static 和 private 函数的 mock。

##### 4.2.2、JMockit

简单易用，可以 mock “一切”，包括 final 类， final/private/static 函数，而其他 mock 框架往往只支持其中一部分；缺点是社区支持不够活跃，3 个 contributers 介乎只有一个在干活，学习曲线比较陡峭。

##### 4.2.3、Easy Mock

上手简单，文档清晰，同样的社区较小，导致更多人选择其它的 mock 框架。

##### 4.2.4、Easy Random

构造随机Java对象

##### 4.2.5、Java Faker

构造随机字符串